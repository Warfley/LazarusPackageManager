#!/usr/bin/env python3
import sys
from typing import List, Tuple
from pathlib import Path
from argparse import ArgumentParser
from os import makedirs
from shutil import get_terminal_size
from download import Downloader, HTTPDownloader, GITDownloader, SVNDownloader
from packagemanager import PackageManager, LocalPackage
from opm import OnlinePackageManager, OPMPackage
from logger import Logger, LogLevel
from project import LazarusProject
from subprocess import call

def handle_update(opm: OnlinePackageManager) -> bool:
    opm.update_package_list()
    return True

def handle_fetch(lpm: PackageManager, opm: OnlinePackageManager, packages: List[str], logger: Logger) -> bool:
    result = True
    for package_name in packages:
        package: OPMPackage = opm.packages.get(package_name)
        if package is None:
            logger.error(f"Package {package_name} not found... skipping")
            result = False
            continue
        result = result and lpm.fetch_opm_package(package)
    return result

def handle_install(lpm: PackageManager, opm: OnlinePackageManager, packages: List[str], logger: Logger) -> bool:
    requires_fetch = [p for p in packages if p not in lpm.packages]
    result = handle_fetch(lpm, opm, requires_fetch, logger)
    for package_name in packages:
        result = result and lpm.install_package(package_name)
    return result

def handle_upgrade(lpm: PackageManager, opm: OnlinePackageManager, packages: List[str], logger: Logger) -> bool:
    result = True
    if len(packages) == 0:
        packages = [name for name, _ in lpm.packages.items()]
    opm_packages: List[str] = [p for p in packages if p in opm.packages]
    for package_name in opm_packages:
        local_package: LocalPackage = lpm.packages.get(package_name)
        if local_package is None:
            logger.error(f"Package {package_name} not found... skipping")
            result = False
            continue
        opm_package: OPMPackage = opm.packages[package_name]
        if local_package.date >= opm_package.file_date:
            logger.log(f"{package_name} is up to date")
            continue
        logger.log(f"updating {package_name}")
        fetch_success = handle_fetch(lpm, opm, [package_name], logger)
        if not fetch_success:
            result = False
            continue
        current_selection: str = lpm.selected_installation
        for lazarus_installation in local_package.installed_in:
            if lpm.select_installation(lazarus_installation):
                result = result and handle_install(lpm, opm, [package_name], logger)
            else:
                result = False
            lpm.select_installation(current_selection)
    return result

def _get_package_list_entry(package: OPMPackage, max_categories: int = 2) -> Tuple[str, str, str]:
    name = package.name
    category_list = package.categories if len(package.categories) <= max_categories else package.categories[:max_categories] + ["..."]
    description = package.description.replace("\r", "").replace("\n", " ")
    return name, ", ".join(category_list), description

def handle_search(opm: OnlinePackageManager, search_string: str) -> bool:
    separator = " | "
    search_results = opm.search_packages(search_string)
    entries = [_get_package_list_entry(package) for package in search_results]
    
    name_column_size = max(len(name for name, _, _ in entries))
    categories_column_size = max(len(categories for _, categories, _ in entries))
    window_size = get_terminal_size((80, 40)).columns
    description_size = window_size - name_column_size - categories_column_size - 3
    
    for name, categories, description in entries:
        name_padding = " " * (name_column_size - len(name))
        categories_padding = " " * (categories_column_size - len(categories))
        if description_size > 0 and len(description) > description_size:
            description = description[:description_size-3] + "..."
        print(f"{name}{name_padding}{separator}{categories}{categories_padding}{separator}{description}")
    return len(search_results) > 0

def handle_direct_download(lpm: PackageManager, name: str, url: str, download_method: str, branch: str, packages: List[str], logger: Logger) -> bool:
    downloader: Downloader = None
    if download_method == "git":
        downloader = GITDownloader(url, branch, logger=logger)
    elif download_method == "svn":
        downloader = SVNDownloader(url, logger=logger)
    elif download_method == "http":
        downloader = HTTPDownloader(url, logger=logger)
    if downloader is None:
        print(f"Download method {download_method} unknown")
        return False
    return lpm.fetch_from_downloader(name, downloader, 0, packages)

def handle_lazarus_installation(lpm: PackageManager, action: str, name: str, path: Path):
    if action == "add":
        return lpm.add_installation(name, path)
    if action == "delete":
        return lpm.remove_installation(name)
    if action == "select":
        return lpm.select_installation(name)
    return False

def handle_build(lpm: PackageManager, opm: OnlinePackageManager, lpi_path: Path, build_modes: List[str], assume_yes: bool, logger: Logger):
    lazbuild_path = lpm.get_lazbuild_path()
    if lazbuild_path is None:
        return False
    project: LazarusProject = LazarusProject(lpi_path)
    base_packages = lpm.get_base_package_files()
    if base_packages is None:
        return False
    project_modes = project.get_build_modes()
    if not build_modes:
        build_modes = project_modes
    dependencies = [f"{d}.lpk".lower() for d in project.get_dependencies()]
    for dependency in dependencies:
        if dependency in base_packages:
            continue
        local_package: LocalPackage = lpm.package_by_lpk(dependency)
        toInstall = None
        if (local_package is not None) and (lpm.selected_installation not in local_package.installed):
            toInstall = local_package.name
        elif local_package is None:
            opmPkg = opm.package_by_file.get(dependency)
            if opmPkg is None:
                logger.error(f"dependency {dependency} could not be resolved")
                return False
            toInstall = opmPkg.name
        if toInstall is not None:
            if not assume_yes:
                print(f"Dependency {dependency} is found but not installed, install now?")
                inp = input("[Y/n] > ")
                if inp.lower() == "n":
                    logger.error(f"dependency {dependency} could not be resolved")
                    return False
            handle_install(lpm, opm, [toInstall], logger)

    result = True
    for build_mode in build_modes:
        if build_mode not in project_modes:
            logger.error(f"Buildmode {build_mode} requested but not available for project")
            result = False
            continue
        result = result and project.build(lazbuild_path, build_mode)
    return result

def handle_self_update():
    git_dir = Path(__file__).resolve().parent
    return call(["git", "pull"], cwd=str(git_dir)) == 0

def main():
    parser = ArgumentParser(description="online package manager CLI")
    parser.add_argument("--target", type=str, help="target directory for the package list and downloaded packages (default=~/.lpm)", default="~/.lpm")
    parser.add_argument("--quiet", "-q", action="store_true", required=False, help="only output errors", default=False)
    action_parser = parser.add_subparsers(dest="mainaction", required=True)

    update_parser = action_parser.add_parser("update", help="updates package list from server")

    upgrade_parser = action_parser.add_parser("upgrade", help="update packages from server")
    upgrade_parser.add_argument("packages", type=str, nargs="*", help="packages to upgrade, if none are given all are updated")

    fetch_parser = action_parser.add_parser("fetch", help="download newest version of a package")
    fetch_parser.add_argument("packages", type=str, help="packages to download", nargs="+")

    install_parser = action_parser.add_parser("install", help="installs the package to a lazarus installation")
    install_parser.add_argument("packages", type=str, help="packages to install", nargs="+")

    search_parser = action_parser.add_parser("search", help="search for packages")
    search_parser.add_argument("searchstring", type=str, help="the string to search for")

    download_parser = action_parser.add_parser("direct-download", help="download a package not using OPM")
    download_parser.add_argument("--type", "-t", type=str, choices=["http", "git", "svn"], help="downloading method. Default=http", default="http")
    download_parser.add_argument("--branch", "-b", type=str, help="branch to checkout (git only). Default=master", default="master")
    download_parser.add_argument("name", type=str, help="the name under which this package will be registered")
    download_parser.add_argument("url", type=str, help="the download url of the file")
    download_parser.add_argument("packages", type=str, nargs="*", help="list of lpk files in that file, if none are given a file search for *.lpk will be done")

    lazarus_parser = action_parser.add_parser("lazarus", help="configure lazarus installations")
    lazarus_parser.add_argument("action", type=str, choices=["add", "delete", "select"], help="action to perform")
    lazarus_parser.add_argument("name", type=str, help="name of the lazarus installation (for references)")
    lazarus_parser.add_argument("path", nargs="?", type=str, help="path of the lazarus installation")

    build_parser = action_parser.add_parser("build", help="buidling lazarus projects")
    build_parser.add_argument("--yes", "-y", action="store_true", default=False, required=False, help="answer all yes-no questions with yes")
    build_parser.add_argument("project", type=str, help="lpi file to build")
    build_parser.add_argument("modes", type=str, nargs="*", help="the build modes to build, if left out, all are build")

    self_update_parser = action_parser.add_parser("self-update", help="Update lpm via git")

    args = parser.parse_args()

    quiet: bool = args.quiet
    target = Path(args.target).expanduser()
    target.mkdir(parents=True, exist_ok=True)

    logger = Logger(LogLevel.WARNING if quiet else LogLevel.DEBUG)

    opm = OnlinePackageManager(target, logger)
    opm.load_package_data()

    lpm = PackageManager(target, logger)
    lpm.load()

    action = args.mainaction
    success = False
    if action == "update":
        success = handle_update(opm)
    elif action == "upgrade":
        success = handle_upgrade(lpm, opm, args.packages, logger)
    elif action == "fetch":
        success = handle_fetch(lpm, opm, args.packages, logger)
    elif action == "install":
        success = handle_install(lpm, opm, args.packages, logger)
    elif action == "search":
        success = handle_search(opm, args.searchstring)
    elif action == "direct-download":
        success = handle_direct_download(lpm, args.name, args.url, args.type, args.branch, args.packages, logger)
    elif action == "lazarus":
        success = handle_lazarus_installation(lpm, args.action, args.name, Path(args.path).expanduser())
    elif action == "build":
        success = handle_build(lpm, opm, Path(args.project).expanduser(), args.modes, args.yes, logger)
    elif action == "self-update":
        success = handle_self_update()

    lpm.save()
    if not success:
        sys.exit(1)


if __name__=="__main__":
    main()
